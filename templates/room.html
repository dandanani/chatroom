{% extends 'base.html' %}
{% block content %}
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%; /* Ensures body takes full viewport height */
    background: var(--bg-color, #ece6fa); /* Default light background */
    color: var(--text-color, black); /* Default text color */
    font-family: Arial, sans-serif;
    transition: background 0.3s, color 0.3s; /* Smooth theme transition */
    overflow: hidden; /* Prevent body scrolling, let internal divs scroll */
  }

  /* Main flex container for the entire chat interface */
  .chat-container {
    display: flex;
    flex-direction: column; /* Stack items vertically */
    height: 100vh; /* Takes full viewport height */
    width: 100vw; /* Takes full viewport width */
    background: linear-gradient(135deg, #ece6fa, #ece6fa); /* Default light gradient */
    padding: 10px; /* Overall padding for the chat interface content */
    box-sizing: border-box; /* Include padding in element's total width/height */
  }

  /* Controls at the top (Room Code, Users, Buttons) */
  .controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap; /* Allow wrapping on very small screens */
    padding-bottom: 10px; /* Space below controls before messages start */
    gap: 10px; /* Space between control items */
  }

  .controls > div {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  /* Video container for local and remote streams */
  .video-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
    flex-wrap: wrap; /* Allow videos to wrap on small screens */
    min-height: 0; /* Allow shrinking */
    max-height: 40%; /* Limit video area height */
    overflow: hidden; /* Hide overflow if videos are too large */
  }

  .video-wrapper {
    position: relative;
    width: 100%; /* Take full width initially */
    max-width: 400px; /* Max width for individual video */
    aspect-ratio: 16 / 9; /* Maintain aspect ratio */
    background-color: #333;
    border-radius: 8px;
    overflow: hidden;
    display: none; /* Hidden by default, shown when call starts */
  }

  .video-wrapper.active {
    display: block; /* Show when active */
  }

  .video-wrapper video {
    width: 100%;
    height: 100%;
    object-fit: cover; /* Cover the area, cropping if necessary */
    border-radius: 8px;
    transform: scaleX(-1); /* Mirror local video */
  }

  .video-label {
    position: absolute;
    bottom: 5px;
    left: 5px;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 0.8em;
  }

  /* Messages display area */
  .messages {
    flex-grow: 1; /* Allows message area to take up all available vertical space */
    overflow-y: auto; /* Enables vertical scrolling when content overflows */
    margin: 0; /* No external margins */
    padding: 10px;
    background: rgba(255, 255, 255, 0.15); /* Slightly transparent background */
    border-radius: 8px;
    backdrop-filter: blur(4px); /* Blurred effect */
    max-height: calc(100vh - 120px); /* Initial placeholder, refined by JS */
  }

  /* Individual message bubble */
  .text {
    background: rgba(0, 0, 0, 0.1); /* Light background for messages */
    margin: 8px 0;
    padding: 10px;
    border-radius: 6px;
    animation: fadeIn 0.2s ease-in-out; /* Smooth fade-in effect */
    font-size: 1.1em; /* Adjusted font size */
    line-height: 1.4; /* Improved readability */
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Container for the input field and send button */
  .inputs-container {
    padding-top: 10px; /* Space above the input bar */
    padding-bottom: env(safe-area-inset-bottom); /* iOS Safe Area for bottom notch/bar */
    background: inherit; /* Inherit background from chat-container for smooth transitions */
    display: flex;
    gap: 10px; /* Space between input and button */
    align-items: center; /* Vertically align items in the input bar */
    flex-shrink: 0; /* Prevent this container from shrinking */
  }

  /* Message input field */
  #message {
    flex-grow: 1; /* Allows input to take up most available width */
    padding: 12px;
    border-radius: 6px;
    border: none;
    outline: none;
    background: rgba(255, 255, 255, 0.2);
    color: black; /* Default text color in input */
    font-size: 1rem; /* Adjusted font size */
  }

  /* Send button */
  #send-btn {
    padding: 12px 18px;
    background: #ff416c; /* Bright pink/red */
    border: none;
    border-radius: 6px;
    color: white;
    cursor: pointer;
    font-weight: bold;
    flex-shrink: 0; /* Prevent button from shrinking */
  }

  #send-btn:hover {
    background: #ff4b2b; /* Slightly darker pink/red on hover */
  }

  /* Typing indicator text */
  .typing {
    font-size: 0.9em; /* Adjusted font size */
    color: #333;
    padding-left: 4px;
    margin-top: 5px; /* Small space above typing indicator */
    min-height: 1.2em; /* Reserve space to prevent layout jumps when text appears/disappears */
  }

  /* Dark Mode Toggle, Leave, and Video Call buttons */
  .dark-mode-toggle, .leave-btn, .video-call-btn, .xox-game-btn {
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 1em; /* Adjusted font size */
    cursor: pointer;
    border: none;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
  }

  .dark-mode-toggle {
    background: #222; /* Dark background for toggle */
    color: white;
  }

  .leave-btn {
    background: crimson; /* Red for leave button */
    color: white;
  }

  .video-call-btn {
    background: #4CAF50; /* Green for video call */
    color: white;
  }

  .video-call-btn.hangup {
    background: #f44336; /* Red for hangup */
  }

  .video-call-btn:hover, .xox-game-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
  }

  .video-call-btn:disabled, .xox-game-btn:disabled {
    background-color: #cccccc; /* Grey out when disabled */
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
  }

  /* XOX Game Specific Styles */
  .xox-game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px; /* Space between game and chat */
      padding: 10px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      width: fit-content; /* Adjust width to content */
      margin-left: auto;
      margin-right: auto;
      display: none; /* Hidden by default */
  }

  .xox-game-container.active {
      display: flex; /* Show when active */
  }

  #xox-board {
      display: grid;
      grid-template-columns: repeat(3, 80px); /* 3 columns, each 80px */
      grid-template-rows: repeat(3, 80px);    /* 3 rows, each 80px */
      gap: 5px;
      background-color: #333;
      border: 5px solid #333;
      border-radius: 5px;
      margin: 10px 0;
  }

  .xox-cell {
      width: 80px;
      height: 80px;
      background-color: #eee;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 3em;
      font-weight: bold;
      cursor: pointer;
      border-radius: 3px;
      transition: background-color 0.2s ease;
      color: black; /* Default color for cell content */
  }

  .xox-cell:hover {
      background-color: #ddd;
  }

  .xox-cell.x {
      color: #ff416c; /* Red for X */
  }

  .xox-cell.o {
      color: #4CAF50; /* Green for O */
  }

  .xox-cell.winning-cell {
      background-color: #ffd700; /* Gold for winning cells */
  }

  #xox-status {
      font-size: 1.1em; /* Adjusted font size */
      margin-bottom: 10px;
      font-weight: bold;
      color: var(--text-color, black);
  }

  #xox-start-btn, #xox-reset-btn {
      padding: 10px 15px;
      font-size: 1em; /* Adjusted font size */
      border-radius: 5px;
      border: none;
      cursor: pointer;
      background-color: #007bff;
      color: white;
      margin-top: 10px;
      display: none; /* Hidden by default, shown when enabled */
  }

  #xox-start-btn:disabled, #xox-reset-btn:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
  }

  #xox-reset-btn {
      background-color: #6c757d;
  }

  /* Message box for alerts/confirmations */
  .message-box-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease;
  }

  .message-box-overlay.show {
    opacity: 1;
    visibility: visible;
  }

  .message-box {
    background: white;
    padding: 25px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    text-align: center;
    max-width: 400px;
    width: 90%;
    color: black;
  }

  .message-box p {
    margin-bottom: 20px;
    font-size: 1.2em;
  }

  .message-box button {
    padding: 10px 20px;
    margin: 0 10px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    transition: background 0.2s ease;
  }

  .message-box button.confirm-btn {
    background: #4CAF50;
    color: white;
  }

  .message-box button.confirm-btn:hover {
    background: #45a049;
  }

  .message-box button.cancel-btn {
    background: #f44336;
    color: white;
  }

  .message-box button.cancel-btn:hover {
    background: #da190b;
  }


  /* Mobile-specific adjustments */
  @media (max-width: 600px) {
    .chat-container {
      padding: 15px 10px; /* Slightly more padding for smaller screens */
    }

    .controls {
      flex-direction: column; /* Stack control items vertically on small screens */
      align-items: flex-start; /* Align stacked items to the left */
      gap: 8px; /* Space between stacked control items */
    }

    .video-wrapper {
      max-width: 100%; /* Allow videos to take full width on small screens */
    }

    #xox-board {
        grid-template-columns: repeat(3, 70px);
        grid-template-rows: repeat(3, 70px);
    }
    .xox-cell {
        width: 70px;
        height: 70px;
        font-size: 2.5em;
    }
  }
</style>

<div class="chat-container">
  <div class="controls">
    <div>
      <strong>Room Code:</strong> {{ code }} |
      <strong>Users:</strong> <span id="user-count">1</span>
    </div>
    <div>
      <button class="video-call-btn" id="video-call-btn" onclick="toggleVideoCall()">ðŸ“ž Start Video Call</button>
      <button class="xox-game-btn" id="xox-game-btn" onclick="toggleXOXVisibility()" disabled>Play XOX</button>
      <button class="dark-mode-toggle" onclick="toggleDarkMode()">ðŸ’¡ Toggle Dark</button>
      <button class="leave-btn" onclick="leaveRoom()">ðŸšª Leave</button>
    </div>
  </div>

  <div class="video-container" id="video-container">
    <div class="video-wrapper" id="local-video-wrapper">
      <video id="local-video" autoplay muted playsinline></video>
      <span class="video-label">You</span>
    </div>
    <div class="video-wrapper" id="remote-video-wrapper">
      <video id="remote-video" autoplay playsinline></video>
      <span class="video-label">Them</span>
    </div>
  </div>

  <div class="xox-game-container" id="xox-game-container">
      <h3 id="xox-status">Waiting for game to start...</h3>
      <div id="xox-board">
          <div class="xox-cell" data-index="0"></div>
          <div class="xox-cell" data-index="1"></div>
          <div class="xox-cell" data-index="2"></div>
          <div class="xox-cell" data-index="3"></div>
          <div class="xox-cell" data-index="4"></div>
          <div class="xox-cell" data-index="5"></div>
          <div class="xox-cell" data-index="6"></div>
          <div class="xox-cell" data-index="7"></div>
          <div class="xox-cell" data-index="8"></div>
      </div>
      <button id="xox-start-btn" onclick="startGame()">Start New XOX Game</button>
      <button id="xox-reset-btn" onclick="resetGame()" style="display: none;">Reset XOX Game</button>
  </div>
  <div class="messages" id="messages"></div>
  <div class="typing" id="typing-indicator"></div>

  <div class="inputs-container">
    <input type="text" placeholder="Message" id="message" onkeypress="handleKeyPress(event)" oninput="notifyTyping()" />
    <button id="send-btn" onClick="sendMessage()">Send</button>
  </div>
</div>

<div class="message-box-overlay" id="message-box-overlay">
  <div class="message-box" id="message-box">
    <p id="message-box-text"></p>
    <div id="message-box-buttons">
      <button class="confirm-btn" id="message-box-confirm">OK</button>
      <button class="cancel-btn" id="message-box-cancel">Cancel</button>
    </div>
  </div>
</div>

<script type="text/javascript">
  const socketio = io();
  const messages = document.getElementById("messages");
  const messageInput = document.getElementById("message");
  const typingIndicator = document.getElementById("typing-indicator");
  const chatContainer = document.querySelector('.chat-container');
  const controls = document.querySelector('.controls');
  const inputsContainer = document.querySelector('.inputs-container');
  const mode = "{{ mode }}"; // Injected by Flask (privacy/fullchat)

  const videoCallBtn = document.getElementById("video-call-btn");
  const localVideo = document.getElementById("local-video");
  const remoteVideo = document.getElementById("remote-video");
  const localVideoWrapper = document.getElementById("local-video-wrapper");
  const remoteVideoWrapper = document.getElementById("remote-video-wrapper");

  let typingTimeout;

  // WebRTC variables
  let localStream;
  let peerConnection;
  let isCalling = false; // Flag to indicate if a call is active or being initiated
  let isInitiator = false; // Flag to determine who creates the offer
  let remoteRequesterSid = null; // Store the SID of the person who initiated the call to you

  // STUN servers (publicly available)
  const iceServers = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      // Add more STUN servers for redundancy if needed
    ]
  };

  // --- Custom Message Box Functions ---
  const showMessageBox = (message, type = 'alert', onConfirm = null, onCancel = null) => {
    const overlay = document.getElementById('message-box-overlay');
    const messageText = document.getElementById('message-box-text');
    const buttonsDiv = document.getElementById('message-box-buttons');
    const confirmBtn = document.getElementById('message-box-confirm');
    const cancelBtn = document.getElementById('message-box-cancel');

    messageText.innerText = message;

    // Reset event listeners
    confirmBtn.onclick = null;
    cancelBtn.onclick = null;

    if (type === 'confirm') {
      cancelBtn.style.display = 'inline-block';
      confirmBtn.innerText = 'Accept';
      confirmBtn.onclick = () => {
        overlay.classList.remove('show');
        if (onConfirm) onConfirm();
      };
      cancelBtn.onclick = () => {
        overlay.classList.remove('show');
        if (onCancel) onCancel();
      };
    } else { // 'alert' type
      cancelBtn.style.display = 'none';
      confirmBtn.innerText = 'OK';
      confirmBtn.onclick = () => {
        overlay.classList.remove('show');
        if (onConfirm) onConfirm();
      };
    }
    overlay.classList.add('show');
  };


  // Function to create and append message elements
  const createMessage = (name, msg) => { // Removed isPrivate as it's not used
    const content = document.createElement("div");
    content.classList.add("text");
    content.innerHTML = `
      <span><strong>${name}</strong>: ${msg}</span>
    `;
    messages.appendChild(content);
    messages.scrollTop = messages.scrollHeight; // Auto-scroll to bottom

    // Auto-delete oldest messages if in privacy mode and limit exceeded
    if (mode === "privacy" && messages.children.length > 5) {
      messages.removeChild(messages.firstChild);
    }
  };

  // Socket.IO event listeners
  socketio.on("message", data => {
    createMessage(data.name, data.message);
  });

  socketio.on("user_count", count => {
    document.getElementById("user-count").innerText = count;
    const xoxGameBtn = document.getElementById('xox-game-btn');
    if (count >= 2) {
        xoxGameBtn.disabled = false;
    } else {
        xoxGameBtn.disabled = true;
        // If less than 2 users and no game is active, hide the game container
        if (!gameActive) {
            xoxGameContainer.classList.remove('active');
            isXOXVisible = false;
            document.getElementById('xox-game-btn').innerText = 'Play XOX';
        }
    }
  });

  socketio.on("typing", data => {
    typingIndicator.innerText = `${data.name} is typing...`;
    clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => typingIndicator.innerText = "", 1500); // Clear after 1.5 seconds
  });

  // --- WebRTC Signaling Events ---
  socketio.on("call_request", (data) => {
    // Only respond if not already in a call or initiating one
    if (isCalling) {
      console.log("Already in a call, rejecting incoming call.");
      socketio.emit("call_response", { action: "reject", requester_sid: data.requester_sid }); // Notify caller of rejection
      return;
    }
    remoteRequesterSid = data.requester_sid; // Store the SID of the caller

    showMessageBox(`${data.from} is calling you. Do you want to accept?`, 'confirm',
      async () => {
        isInitiator = false; // The recipient is not the initiator of the offer
        isCalling = true; // Mark as calling before trying to start stream
        videoCallBtn.innerText = "Hang Up";
        videoCallBtn.classList.add("hangup");
        videoCallBtn.disabled = true; // Disable until connection established or rejected

        const setupSuccess = await startVideoCallInternal();
        if (setupSuccess) {
          socketio.emit("call_response", { action: "accept", requester_sid: remoteRequesterSid });
          await createAnswer();
          createMessage("System", `You accepted a call from ${data.from}.`);
          videoCallBtn.disabled = false; // Re-enable once call is accepted and potentially connected
        } else {
          socketio.emit("call_response", { action: "reject", requester_sid: remoteRequesterSid });
          createMessage("System", "Could not start video call. Check permissions/devices.");
          endVideoCall(); // Clean up if start failed
        }
      },
      () => {
        socketio.emit("call_response", { action: "reject", requester_sid: remoteRequesterSid });
        createMessage("System", `You rejected a call from ${data.from}.`);
        remoteRequesterSid = null; // Clear the requester SID
      }
    );
  });

  socketio.on("call_accepted", async (data) => {
      isCalling = true;
      videoCallBtn.innerText = "Hang Up";
      videoCallBtn.classList.add("hangup");
      videoCallBtn.disabled = false; // Re-enable after acceptance
      createMessage("System", `${data.from} accepted your call.`);
      await createOffer(); // Initiator creates offer after acceptance
  });

  socketio.on("call_rejected", (data) => {
    showMessageBox(`${data.from} ${data.reason}`, 'alert');
    endVideoCall(); // Clean up if call was initiated but rejected
  });

  socketio.on("call_status", (data) => {
      createMessage("System", data.message);
  });


  socketio.on("offer", async (data) => {
    // Ensure peerConnection is ready before setting remote description
    if (!peerConnection) {
        console.warn("Offer received but peerConnection not ready. Delaying or re-initializing.");
        // This scenario should be rare with the new call_request/response flow
        // but if it happens, ensure local setup is complete.
        const setupSuccess = await startVideoCallInternal();
        if (!setupSuccess) {
            console.error("Failed to setup peer connection on offer receive.");
            return;
        }
    }
    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
    // If we are not the initiator (i.e., we received the offer), we need to create an answer
    if (!isInitiator) {
      await createAnswer();
    }
  });

  socketio.on("answer", async (data) => {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
  });

  socketio.on("ice_candidate", async (data) => {
    try {
      if (peerConnection && data.candidate) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    } catch (e) {
      console.error("Error adding received ICE candidate:", e);
    }
  });

  socketio.on("call_end", (data) => {
    endVideoCall();
    createMessage("System", `${data.name} has ended the video call.`);
  });

  // --- WebRTC Functions ---

  const startVideoCallInternal = async () => {
    try {
      // Get local media stream (camera and microphone)
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localVideo.srcObject = localStream;
      localVideoWrapper.classList.add('active'); // Show local video

      // Create PeerConnection
      peerConnection = new RTCPeerConnection(iceServers);

      // Add local tracks to peer connection
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // Handle ICE candidates (network information)
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socketio.emit("ice_candidate", { candidate: event.candidate });
        }
      };

      // Handle incoming remote tracks
      peerConnection.ontrack = (event) => {
        if (remoteVideo.srcObject !== event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
          remoteVideoWrapper.classList.add('active'); // Show remote video
          // createMessage("System", "Video call connected!"); // This can be removed or refined
        }
      };

      peerConnection.onconnectionstatechange = (event) => {
        console.log('PeerConnection state change:', peerConnection.connectionState);
        if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
          if (isCalling) {
            // Only consider call ended if it was active and not manually hung up
            if (videoCallBtn.innerText !== "ðŸ“ž Start Video Call") { // Check if it's not already reset
                endVideoCall();
                createMessage("System", "Video call disconnected due to network issues or peer leaving.");
            }
          }
        } else if (peerConnection.connectionState === 'connected') {
          createMessage("System", "Video call connected!");
        }
      };

      peerConnection.oniceconnectionstatechange = (event) => {
        console.log('ICE connection state change:', peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected') {
          // More granular handling of ICE failures if needed
        }
      };

      return true; // Indicate success
    } catch (error) {
      console.error("Error accessing media devices or setting up WebRTC:", error);
      endVideoCall(); // Clean up any partial setup

      let errorMessage = "Could not start video call. ";
      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
        errorMessage += "Please grant camera and microphone permissions in your browser settings.";
      } else if (error.name === 'NotFoundError') {
        errorMessage += "No camera or microphone found. Please ensure devices are connected.";
      } else {
        errorMessage += `An unexpected error occurred: ${error.name} - ${error.message}`;
      }
      showMessageBox(errorMessage, 'alert');
      videoCallBtn.disabled = true; // Disable button after a persistent error
      videoCallBtn.innerText = "Error!";
      return false; // Indicate failure
    }
  };

  const createOffer = async () => {
    try {
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socketio.emit("offer", { offer: peerConnection.localDescription });
    } catch (error) {
      console.error("Error creating offer:", error);
    }
  };

  const createAnswer = async () => {
    try {
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      socketio.emit("answer", { answer: peerConnection.localDescription });
    } catch (error) {
      console.error("Error creating answer:", error);
    }
  };

  const endVideoCall = () => {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    localVideo.srcObject = null;
    remoteVideo.srcObject = null;
    localVideoWrapper.classList.remove('active');
    remoteVideoWrapper.classList.remove('active');
    isCalling = false;
    isInitiator = false;
    remoteRequesterSid = null; // Clear this on call end
    videoCallBtn.innerText = "ðŸ“ž Start Video Call";
    videoCallBtn.classList.remove("hangup");
    videoCallBtn.disabled = false; // Re-enable button
  };

  // --- User Interaction Functions ---
  const sendMessage = () => {
    const msg = messageInput.value.trim();
    if (msg === "") return; // Don't send empty messages
    socketio.emit("message", { data: msg });
    messageInput.value = ""; // Clear input field
  };

  const handleKeyPress = event => {
    if (event.key === "Enter") sendMessage(); // Send on Enter key
  };

  const notifyTyping = () => {
    socketio.emit("typing"); // Notify server when user types
  };

  const toggleVideoCall = async () => {
    if (videoCallBtn.disabled && videoCallBtn.innerText !== "Calling...") { // Allow re-clicks if "Calling..."
      showMessageBox("Video call is unavailable. Please check camera/microphone permissions or device connection.", 'alert');
      return;
    }

    if (!isCalling) {
      const userCount = parseInt(document.getElementById("user-count").innerText);
      if (userCount < 2) {
        showMessageBox("Need at least 2 users in the room for a video call.", 'alert');
        return;
      }

      // Initiate a new call
      isInitiator = true;
      videoCallBtn.innerText = "Calling...";
      videoCallBtn.classList.add("hangup"); // Visually indicate active state
      videoCallBtn.disabled = true; // Disable during call initiation

      const setupSuccess = await startVideoCallInternal(); // Setup local stream and peer connection
      if (!setupSuccess) {
        // If setup failed (e.g., permissions denied), end the process
        isCalling = false; // Ensure isCalling is false
        isInitiator = false;
        videoCallBtn.innerText = "ðŸ“ž Start Video Call"; // Reset button text
        videoCallBtn.classList.remove("hangup");
        // Button might remain disabled if permission was denied due to error in startVideoCallInternal
        return;
      }

      isCalling = true; // Mark as calling only if setup was successful
      socketio.emit("call_request"); // Notify other user in the room

      // Set a timeout to automatically end the call if no answer
      setTimeout(() => {
        // Check if the call is still in the 'calling' state (isInitiator, isCalling, no remote description yet)
        if (isCalling && isInitiator && peerConnection && !peerConnection.remoteDescription) {
          showMessageBox("No one answered your call.", 'alert');
          socketio.emit("call_end"); // Inform the server to clean up
          endVideoCall();
        }
      }, 30000); // 30 seconds timeout
    } else {
      // End the current call
      socketio.emit("call_end"); // Notify the other peer and server
      endVideoCall();
    }
  };

  // Toggle Dark/Light Mode
  const toggleDarkMode = () => {
    const body = document.body;
    const isDark = body.style.getPropertyValue("--bg-color") === "black";

    // Set body background and text color
    body.style.setProperty("--bg-color", isDark ? "#ece6fa" : "black");
    body.style.setProperty("--text-color", isDark ? "black" : "white");

    // Adjust chat container and input container backgrounds
    const chatBgLight = "linear-gradient(135deg, #ece6fa, #ece6fa)";
    const chatBgDark = "linear-gradient(135deg, #222, #333)";

    document.querySelector('.chat-container').style.background = isDark ? chatBgLight : chatBgDark;
    document.querySelector('.inputs-container').style.background = isDark ? chatBgLight : chatBgDark;

    // Adjust input text color for readability in dark mode
    messageInput.style.color = isDark ? 'black' : 'white';
  };

  const leaveRoom = () => {
    if (isCalling) {
      socketio.emit("call_end"); // End call before leaving
    }
    socketio.emit("leave_room");
    window.location.href = "/"; // Redirect to home page
  };

  // --- XOX Game Variables and Functions ---
  const xoxGameContainer = document.getElementById('xox-game-container');
  const xoxBoard = document.getElementById('xox-board');
  const xoxCells = document.querySelectorAll('.xox-cell');
  const xoxStatus = document.getElementById('xox-status');
  const xoxStartBtn = document.getElementById('xox-start-btn');
  const xoxResetBtn = document.getElementById('xox-reset-btn');

  let board = ['', '', '', '', '', '', '', '', ''];
  let currentPlayer = 'X'; // 'X' always starts
  let gameActive = false;
  let yourSymbol = null; // 'X' or 'O' for the current client (if playing)
  let isYourTurn = false; // Flag for current client's turn
  let playerXName = '';
  let playerOName = '';
  let isXOXVisible = false;

  const winningConditions = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
      [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
      [0, 4, 8], [2, 4, 6]            // Diagonals
  ];

  const toggleXOXVisibility = () => {
      isXOXVisible = !isXOXVisible;
      if (isXOXVisible) {
          xoxGameContainer.classList.add('active');
          document.getElementById('xox-game-btn').innerText = 'Hide XOX';
          // Ensure board state is correct when shown
          updateGameStatus();
          adjustLayoutForKeyboard(); // Readjust layout when game becomes visible
      } else {
          xoxGameContainer.classList.remove('active');
          document.getElementById('xox-game-btn').innerText = 'Play XOX';
          adjustLayoutForKeyboard(); // Readjust layout when game hides
      }
  };

  const initializeBoard = () => {
      board = ['', '', '', '', '', '', '', '', ''];
      xoxCells.forEach(cell => {
          cell.innerText = '';
          cell.classList.remove('x', 'o', 'winning-cell');
          cell.style.pointerEvents = 'none'; // Disable clicks initially
          // Re-add event listener if it was removed by { once: true }
          cell.removeEventListener('click', handleCellClick); // Remove existing to prevent duplicates
          cell.addEventListener('click', handleCellClick);
      });
      gameActive = false;
      yourSymbol = null;
      isYourTurn = false;
      playerXName = '';
      playerOName = '';
      xoxStatus.innerText = 'Need 2 players to start XOX.'; // Default status
      xoxStartBtn.style.display = 'block';
      xoxResetBtn.style.display = 'none';
      currentPlayer = 'X'; // Reset current player for next game
      // Disable start button until socketio.on("enable_game_start")
      xoxStartBtn.disabled = true;
  };

  const checkWinner = () => {
      let roundWon = false;
      let winningCells = [];
      for (let i = 0; i < winningConditions.length; i++) {
          const winCondition = winningConditions[i];
          let a = board[winCondition[0]];
          let b = board[winCondition[1]];
          let c = board[winCondition[2]];

          if (a === '' || b === '' || c === '') {
              continue;
          }
          if (a === b && b === c) {
              roundWon = true;
              winningCells = winCondition;
              break;
          }
      }

      if (roundWon) {
          gameActive = false;
          highlightWinningCells(winningCells);
          const winnerDisplay = board[winningCells[0]] === 'X' ? playerXName : playerOName;
          const winnerSymbol = board[winningCells[0]];
          xoxStatus.innerText = `${winnerDisplay} (${winnerSymbol}) has won!`;
          socketio.emit("game_over", { winner: winnerSymbol, draw: false, message: `${winnerDisplay} won the XOX game!` });
          xoxStartBtn.style.display = 'none';
          xoxResetBtn.style.display = 'block';
          return true;
      }

      if (!board.includes('')) {
          gameActive = false;
          xoxStatus.innerText = 'Game Draw!';
          socketio.emit("game_over", { winner: null, draw: true, message: "XOX game ended in a draw!" });
          xoxStartBtn.style.display = 'none';
          xoxResetBtn.style.display = 'block';
          return true;
      }
      return false;
  };

  const highlightWinningCells = (cells) => {
      cells.forEach(index => {
          xoxCells[index].classList.add('winning-cell');
      });
  };

  const handleCellClick = (event) => {
      const clickedCell = event.target;
      const clickedCellIndex = parseInt(clickedCell.dataset.index);

      if (!gameActive || board[clickedCellIndex] !== '' || !isYourTurn) {
          // console.log("Can't click: Game not active, cell filled, or not your turn.");
          return;
      }

      // Local update immediately for responsiveness
      board[clickedCellIndex] = yourSymbol;
      clickedCell.innerText = yourSymbol;
      clickedCell.classList.add(yourSymbol.toLowerCase());
      clickedCell.style.pointerEvents = 'none'; // Disable click on this cell

      // Calculate next turn symbol
      const nextPlayerSymbol = yourSymbol === 'X' ? 'O' : 'X';

      // Emit move to server
      socketio.emit("game_move", {
          index: clickedCellIndex,
          symbol: yourSymbol,
          next_turn_symbol: nextPlayerSymbol,
          board_state: board // Send current board state for server validation
      });

      isYourTurn = false; // It's no longer your turn
      updateGameStatus(); // Update status locally immediately
  };

  // --- Socket.IO Game Event Handlers ---

  socketio.on("enable_game_start", () => {
      const userCount = parseInt(document.getElementById("user-count").innerText);
      if (userCount >= 2 && !gameActive) {
          xoxStartBtn.disabled = false;
          xoxStatus.innerText = 'Two players are in the room. Click "Start New XOX Game"!';
      }
  });

  socketio.on("disable_game_start", () => {
      xoxStartBtn.disabled = true;
      if (!gameActive) {
          xoxStatus.innerText = 'Need 2 players to start XOX.';
      }
  });

  socketio.on("game_status", (data) => {
      createMessage("System", `XOX: ${data.message}`);
      if (!gameActive) { // If no game is active, update the game status on the board itself
        xoxStatus.innerText = data.message;
      }
  });

  socketio.on("game_start", (data) => {
      initializeBoard(); // Reset board visual and logic
      gameActive = true;
      yourSymbol = data.your_symbol; // Assign 'X' or 'O' to this client
      isYourTurn = data.is_your_turn; // True if X, False if O
      playerXName = data.player_x_name;
      playerOName = data.player_o_name;

      xoxStartBtn.style.display = 'none';
      xoxResetBtn.style.display = 'none';

      createMessage("System", `XOX game started! ${playerXName} is X, ${playerOName} is O. You are **${yourSymbol}**.`);
      updateGameStatus();
  });

  socketio.on("game_update", (data) => {
      // Only update if the game is active and the move is valid for the current board state
      if (!gameActive || board[data.index] !== '') {
          // This should ideally not happen if server validates, but good client-side guard
          console.warn("Received invalid game update or game not active.");
          return;
      }

      board[data.index] = data.symbol;
      const cell = xoxCells[data.index];
      cell.innerText = data.symbol;
      cell.classList.add(data.symbol.toLowerCase());
      cell.style.pointerEvents = 'none'; // Disable click on this cell

      // Determine if it's THIS client's turn next
      isYourTurn = (data.current_turn_sid === socketio.id); // Compare incoming SID to local SID

      updateGameStatus();
      checkWinner(); // Check for winner after every move
  });

  socketio.on("game_result", (data) => {
      gameActive = false;
      isYourTurn = false; // Game over, no one's turn
      xoxStartBtn.style.display = 'none';
      xoxResetBtn.style.display = 'block';
      createMessage("System", `XOX Game Over: ${data.message}`);
      if (data.draw) {
          xoxStatus.innerText = 'Game Draw!';
      } else if (data.winner) {
          const winnerDisplayName = data.winner === 'X' ? playerXName : playerOName;
          xoxStatus.innerText = `${winnerDisplayName} (${data.winner}) has won!`;
      }
      xoxCells.forEach(cell => cell.style.pointerEvents = 'none'); // Disable all cells
      xoxStartBtn.disabled = false; // Re-enable start button
  });

  socketio.on("game_reset", (data) => {
      initializeBoard();
      createMessage("System", `XOX Game Reset: ${data.reason}`);
      // Re-enable start button if two players are present after reset
      const userCount = parseInt(document.getElementById("user-count").innerText);
      if (userCount >= 2) {
          xoxStartBtn.disabled = false;
          xoxStatus.innerText = 'Two players are in the room. Click "Start New XOX Game"!';
      } else {
          xoxStatus.innerText = 'Need 2 players to start XOX.';
      }
  });


  const startGame = () => {
      if (parseInt(document.getElementById("user-count").innerText) < 2) {
          showMessageBox("You need 2 players in the room to start an XOX game.", 'alert');
          return;
      }
      xoxStartBtn.disabled = true; // Disable to prevent multiple requests
      socketio.emit("game_start_request");
  };

  const resetGame = () => {
      xoxResetBtn.disabled = true; // Disable to prevent multiple requests
      socketio.emit("game_reset_request");
  };

  const updateGameStatus = () => {
    if (!gameActive) {
        // If game is not active, status might be a win/draw message or "waiting for players"
        // Don't overwrite if it's already a win/draw message
        if (!xoxStatus.innerText.includes("won") && !xoxStatus.innerText.includes("Draw") && yourSymbol === null) {
            const userCount = parseInt(document.getElementById("user-count").innerText);
            xoxStatus.innerText = userCount < 2 ? 'Need 2 players to start XOX.' : 'Waiting for a new game to start.';
        }
    } else {
        const currentPlayerName = currentPlayer === 'X' ? playerXName : playerOName;
        const yourTurnText = isYourTurn ? 'Your turn!' : '';
        xoxStatus.innerText = `${currentPlayerName}'s turn (${currentPlayer}). ${yourTurnText}`;
    }
    // Only enable cell clicks if it's your turn and game is active
    xoxCells.forEach(cell => {
        if (gameActive && isYourTurn && board[parseInt(cell.dataset.index)] === '') {
            cell.style.pointerEvents = 'auto'; // Enable click
        } else {
            cell.style.pointerEvents = 'none'; // Disable click
        }
    });
  };

  // Initialize XOX board on load
  initializeBoard();

  // --- Mobile Keyboard Alignment Logic ---
  const adjustLayoutForKeyboard = () => {
    // Get the current visual viewport height (which shrinks when keyboard is open)
    const viewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;

    // Calculate heights of fixed/known elements
    const controlsHeight = controls.offsetHeight;
    const inputsHeight = inputsContainer.offsetHeight;
    // Account for typing indicator potentially being empty (min-height)
    const typingIndicatorHeight = typingIndicator.innerText ? typingIndicator.offsetHeight : 0;
    const videoContainerHeight = document.getElementById('video-container').offsetHeight; // Height of video section
    const xoxContainerHeight = isXOXVisible ? xoxGameContainer.offsetHeight : 0; // Only add if game is visible

    const chatContainerPaddingTop = parseFloat(getComputedStyle(chatContainer).paddingTop);
    const chatContainerPaddingBottom = parseFloat(getComputedStyle(chatContainer).paddingBottom);
    const totalContainerPadding = chatContainerPaddingTop + chatContainerPaddingBottom;

    // Calculate available height for messages
    const messagesAvailableHeight = viewportHeight - controlsHeight - inputsHeight - typingIndicatorHeight - videoContainerHeight - xoxContainerHeight - totalContainerPadding;

    // Set max-height of messages area to fit available space
    messages.style.maxHeight = `${messagesAvailableHeight}px`;

    // Ensure scroll to bottom after layout adjustment
    messages.scrollTop = messages.scrollHeight;
  };

  // Listen for visual viewport resize (this fires reliably on keyboard show/hide)
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', adjustLayoutForKeyboard);
  } else {
    // Fallback for browsers that don't support visualViewport (less precise, often fires on scroll)
    window.addEventListener('resize', adjustLayoutForKeyboard);
  }

  // Initial layout adjustment on page load
  window.addEventListener('load', () => {
    adjustLayoutForKeyboard();
    // Initial check for game button state
    const userCount = parseInt(document.getElementById("user-count").innerText);
    if (userCount >= 2 && !gameActive) {
        document.getElementById('xox-game-btn').disabled = false;
        xoxStartBtn.disabled = false;
        xoxStatus.innerText = 'Two players are in the room. Click "Start New XOX Game"!';
    } else {
        document.getElementById('xox-game-btn').disabled = true;
        xoxStartBtn.disabled = true;
    }
  });
  messageInput.addEventListener('focus', adjustLayoutForKeyboard); // Re-adjust when input is focused
  messageInput.addEventListener('blur', adjustLayoutForKeyboard);  // Re-adjust when input loses focus

</script>

{% for msg in messages %}
<script type="text/javascript">
  // Populate initial messages when the page loads
  createMessage("{{ msg.name }}", "{{ msg.message }}");
</script>
{% endfor %}
{% endblock %}