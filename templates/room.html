{% extends 'base.html' %}
{% block content %}
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: var(--bg-color, #ece6fa);
    color: var(--text-color, black);
    font-family: Arial, sans-serif;
    transition: background 0.3s, color 0.3s;
    overflow: hidden;
  }

  /* Main flex container for the entire chat interface */
  .chat-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    background: linear-gradient(135deg, #ece6fa, #ece6fa);
    padding: 10px;
    box-sizing: border-box;
  }

  /* Controls at the top (Room Code, Users, Buttons) */
  .controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    padding-bottom: 10px;
    gap: 10px;
  }

  .controls > div {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  /* Video container for local and remote streams */
  .video-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
    flex-wrap: wrap;
    min-height: 0;
    max-height: 40%;
    overflow: hidden;
    position: relative; /* For fullscreen positioning */
    background-color: #333; /* Default background when no video */
    border-radius: 8px;
  }

  .video-container.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    max-height: 100vh;
    z-index: 999; /* Above other content */
    background-color: black;
    display: flex;
    flex-direction: column; /* Stack videos vertically in fullscreen */
    justify-content: center;
    align-items: center;
    padding: 0;
    border-radius: 0;
  }

  .video-wrapper {
    position: relative;
    width: 100%;
    max-width: 400px;
    aspect-ratio: 16 / 9;
    background-color: #333;
    border-radius: 8px;
    overflow: hidden;
    display: none;
  }

  .video-container.fullscreen .video-wrapper {
    max-width: 90vw; /* Adjust max width in fullscreen */
    max-height: 45vh; /* Distribute height for two videos */
    margin: 5px; /* Small margin between videos */
  }

  .video-wrapper.active {
    display: block;
  }

  .video-wrapper video {
    width: 100%;
    height: 100%;
    object-fit: contain; /* Use 'contain' for fullscreen to see whole video */
    border-radius: 8px;
    transform: scaleX(-1);
  }

  .video-label {
    position: absolute;
    bottom: 5px;
    left: 5px;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 0.8em;
  }

  /* Video Controls Overlay */
  .video-controls-overlay {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.6);
    border-radius: 15px;
    padding: 8px 15px;
    display: flex;
    gap: 10px;
    z-index: 100;
  }

  .video-controls-overlay button {
    background: none;
    border: none;
    color: white;
    font-size: 1.5em;
    cursor: pointer;
    padding: 5px;
    transition: color 0.2s ease;
  }

  .video-controls-overlay button:hover {
    color: #4CAF50;
  }

  .video-controls-overlay button.active {
    color: #f44336; /* Muted/active state */
  }

  /* Messages display area */
  .messages {
    flex-grow: 1;
    overflow-y: auto;
    margin: 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 8px;
    backdrop-filter: blur(4px);
    max-height: calc(100vh - 120px);
  }

  /* Individual message bubble */
  .text {
    margin: 8px 0;
    padding: 10px;
    border-radius: 6px;
    animation: fadeIn 0.2s ease-in-out;
    font-size: 1.1em;
    line-height: 1.4;
    color: black; /* Ensure text is black */
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Container for the input field and send button */
  .inputs-container {
    padding-top: 10px;
    padding-bottom: env(safe-area-inset-bottom);
    background: inherit;
    display: flex;
    gap: 10px;
    align-items: center;
    flex-shrink: 0;
  }

  /* Message input field */
  #message {
    flex-grow: 1;
    padding: 12px;
    border-radius: 6px;
    border: none;
    outline: none;
    background: rgba(255, 255, 255, 0.2);
    color: black;
    font-size: 1rem;
  }

  /* Send button */
  #send-btn {
    padding: 12px 18px;
    background: #ff416c;
    border: none;
    border-radius: 6px;
    color: white;
    cursor: pointer;
    font-weight: bold;
    flex-shrink: 0;
  }

  #send-btn:hover {
    background: #ff4b2b;
  }

  /* Typing indicator text */
  .typing {
    font-size: 0.9em;
    color: #333;
    padding-left: 4px;
    margin-top: 5px;
    min-height: 1.2em;
  }

  /* Dark Mode Toggle, Leave, and Video Call buttons */
  .dark-mode-toggle, .leave-btn, .video-call-btn, .xox-game-btn {
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 1em;
    cursor: pointer;
    border: none;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
  }

  .dark-mode-toggle {
    background: #222;
    color: white;
  }

  .leave-btn {
    background: crimson;
    color: white;
  }

  .video-call-btn {
    background: #4CAF50;
    color: white;
  }

  .video-call-btn.hangup {
    background: #f44336;
  }

  .video-call-btn:hover, .xox-game-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
  }

  .video-call-btn:disabled, .xox-game-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
  }

  /* XOX Game Specific Styles */
  .xox-game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      width: fit-content;
      margin-left: auto;
      margin-right: auto;
      display: none;
  }

  .xox-game-container.active {
      display: flex;
  }

  #xox-board {
      display: grid;
      grid-template-columns: repeat(3, 80px);
      grid-template-rows: repeat(3, 80px);
      gap: 5px;
      background-color: #333;
      border: 5px solid #333;
      border-radius: 5px;
      margin: 10px 0;
  }

  .xox-cell {
      width: 80px;
      height: 80px;
      background-color: #eee;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 3em;
      font-weight: bold;
      cursor: pointer;
      border-radius: 3px;
      transition: background-color 0.2s ease;
      color: black;
  }

  .xox-cell:hover {
      background-color: #ddd;
  }

  .xox-cell.x {
      color: #ff416c;
  }

  .xox-cell.o {
      color: #4CAF50;
  }

  .xox-cell.winning-cell {
      background-color: #ffd700;
  }

  #xox-status {
      font-size: 1.1em;
      margin-bottom: 10px;
      font-weight: bold;
      color: var(--text-color, black);
  }

  #xox-start-btn, #xox-reset-btn {
      padding: 10px 15px;
      font-size: 1em;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      background-color: #007bff;
      color: white;
      margin-top: 10px;
      display: none;
  }

  #xox-start-btn:disabled, #xox-reset-btn:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
  }

  #xox-reset-btn {
      background-color: #6c757d;
  }

  /* Message box for alerts/confirmations */
  .message-box-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease;
  }

  .message-box-overlay.show {
    opacity: 1;
    visibility: visible;
  }

  .message-box {
    background: white;
    padding: 25px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    text-align: center;
    max-width: 400px;
    width: 90%;
    color: black;
  }

  .message-box p {
    margin-bottom: 20px;
    font-size: 1.2em;
  }

  .message-box button {
    padding: 10px 20px;
    margin: 0 10px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    transition: background 0.2s ease;
  }

  .message-box button.confirm-btn {
    background: #4CAF50;
    color: white;
  }

  .message-box button.confirm-btn:hover {
    background: #45a049;
  }

  .message-box button.cancel-btn {
    background: #f44336;
    color: white;
  }

  .message-box button.cancel-btn:hover {
    background: #da190b;
  }

  /* User Selection Modal (for multi-person call) */
  .user-selection-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1001; /* Above message box */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease;
  }

  .user-selection-modal-overlay.show {
    opacity: 1;
    visibility: visible;
  }

  .user-selection-modal {
    background: white;
    padding: 25px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    text-align: center;
    max-width: 400px;
    width: 90%;
    color: black;
  }

  .user-selection-modal h3 {
    margin-top: 0;
    margin-bottom: 20px;
    color: #4a2a82;
  }

  .user-selection-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid #eee;
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 20px;
    text-align: left;
  }

  .user-selection-list label {
    display: block;
    margin-bottom: 8px;
    font-size: 1.1em;
    cursor: pointer;
  }

  .user-selection-list input[type="checkbox"] {
    margin-right: 10px;
  }

  .user-selection-modal .modal-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
  }

  .user-selection-modal .modal-buttons button {
    padding: 10px 20px;
    border-radius: 5px;
    font-size: 1em;
  }

  /* Mobile-specific adjustments */
  @media (max-width: 600px) {
    .chat-container {
      padding: 15px 10px;
    }

    .controls {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }

    .video-wrapper {
      max-width: 100%;
    }

    #xox-board {
        grid-template-columns: repeat(3, 70px);
        grid-template-rows: repeat(3, 70px);
    }
    .xox-cell {
        width: 70px;
        height: 70px;
        font-size: 2.5em;
    }
  }
</style>

<div class="chat-container">
  <div class="controls">
    <div>
      <strong>Room Code:</strong> {{ code }} |
      <strong>Users:</strong> <span id="user-count">1</span>
    </div>
    <div>
      <span style="font-weight: bold; color: var(--text-color, black);">Logged in as: {{ name }}</span>
    </div>
    <div>
      <button class="video-call-btn" id="video-call-btn" onclick="toggleVideoCall()">📞 Start Video Call</button>
      <button class="xox-game-btn" id="xox-game-btn" onclick="toggleXOXVisibility()" disabled>Play XOX</button>
      <button class="dark-mode-toggle" onclick="toggleDarkMode()">💡 Toggle Dark</button>
      <button class="leave-btn" onclick="leaveRoom()">🚪 Leave</button>
    </div>
  </div>

  <div class="video-container" id="video-container">
    <div class="video-wrapper" id="local-video-wrapper">
      <video id="local-video" autoplay muted playsinline></video>
      <span class="video-label">You</span>
    </div>
    <div class="video-wrapper" id="remote-video-wrapper">
      <video id="remote-video" autoplay playsinline></video>
      <span class="video-label">Them</span>
    </div>
    <div class="video-controls-overlay">
      <button id="mute-toggle-btn" onclick="toggleMute()">🔇</button>
      <button id="camera-switch-btn" onclick="switchCamera()">🔄</button>
      <button id="fullscreen-toggle-btn" onclick="toggleFullscreen()"> expand_content </button>
    </div>
  </div>

  <!-- XOX Game Section -->
  <div class="xox-game-container" id="xox-game-container">
      <h3 id="xox-status">Waiting for game to start...</h3>
      <div id="xox-board">
          <div class="xox-cell" data-index="0"></div>
          <div class="xox-cell" data-index="1"></div>
          <div class="xox-cell" data-index="2"></div>
          <div class="xox-cell" data-index="3"></div>
          <div class="xox-cell" data-index="4"></div>
          <div class="xox-cell" data-index="5"></div>
          <div class="xox-cell" data-index="6"></div>
          <div class="xox-cell" data-index="7"></div>
          <div class="xox-cell" data-index="8"></div>
      </div>
      <button id="xox-start-btn" onclick="startGame()">Start New XOX Game</button>
      <button id="xox-reset-btn" onclick="resetGame()" style="display: none;">Reset XOX Game</button>
  </div>
  <!-- End XOX Game Section -->

  <div class="messages" id="messages"></div>
  <div class="typing" id="typing-indicator"></div>

  <div class="inputs-container">
    <input type="text" placeholder="Message" id="message" onkeypress="handleKeyPress(event)" oninput="notifyTyping()" />
    <button id="send-btn" onClick="sendMessage()">Send</button>
  </div>
</div>

<!-- Custom Message Box for alerts/confirmations -->
<div class="message-box-overlay" id="message-box-overlay">
  <div class="message-box" id="message-box">
    <p id="message-box-text"></p>
    <div id="message-box-buttons">
      <button class="confirm-btn" id="message-box-confirm">OK</button>
      <button class="cancel-btn" id="message-box-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- User Selection Modal for Video Call -->
<div class="user-selection-modal-overlay" id="user-selection-modal-overlay">
  <div class="user-selection-modal">
    <h3>Select Users for Video Call</h3>
    <div class="user-selection-list" id="user-selection-list">
      <!-- Users will be dynamically inserted here -->
    </div>
    <div class="modal-buttons">
      <button class="confirm-btn" id="select-users-confirm">Start Call</button>
      <button class="cancel-btn" id="select-users-cancel">Cancel</button>
    </div>
  </div>
</div>


<script type="text/javascript">
  const socketio = io();
  const messages = document.getElementById("messages");
  const messageInput = document.getElementById("message");
  const typingIndicator = document.getElementById("typing-indicator");
  const chatContainer = document.querySelector('.chat-container');
  const controls = document.querySelector('.controls');
  const inputsContainer = document.querySelector('.inputs-container');
  const mode = "{{ mode }}"; // Injected by Flask (privacy/fullchat)

  const videoCallBtn = document.getElementById("video-call-btn");
  const localVideo = document.getElementById("local-video");
  const remoteVideo = document.getElementById("remote-video");
  const localVideoWrapper = document.getElementById("local-video-wrapper");
  const remoteVideoWrapper = document.getElementById("remote-video-wrapper");
  const videoContainer = document.getElementById("video-container"); // New reference for fullscreen

  const muteToggleButton = document.getElementById("mute-toggle-btn");
  const cameraSwitchButton = document.getElementById("camera-switch-btn");
  const fullscreenToggleButton = document.getElementById("fullscreen-toggle-btn");

  let typingTimeout;

  // WebRTC variables
  let localStream;
  let peerConnection;
  let isCalling = false; // Flag to indicate if a call is active or being initiated
  let isInitiator = false; // Flag to determine who creates the offer
  let remoteRequesterSid = null; // Store the SID of the person who initiated the call to you
  let currentCameraDeviceId = null; // To keep track of the active camera

  // Store online users for selection modal
  let onlineUsers = [];

  // STUN servers (publicly available)
  const iceServers = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' },
    ]
  };

  // --- Custom Message Box Functions ---
  const showMessageBox = (message, type = 'alert', onConfirm = null, onCancel = null) => {
    const overlay = document.getElementById('message-box-overlay');
    const messageText = document.getElementById('message-box-text');
    const confirmBtn = document.getElementById('message-box-confirm');
    const cancelBtn = document.getElementById('message-box-cancel');

    messageText.innerText = message;

    confirmBtn.onclick = null;
    cancelBtn.onclick = null;

    if (type === 'confirm') {
      cancelBtn.style.display = 'inline-block';
      confirmBtn.innerText = 'Accept';
      confirmBtn.onclick = () => {
        overlay.classList.remove('show');
        if (onConfirm) onConfirm();
      };
      cancelBtn.onclick = () => {
        overlay.classList.remove('show');
        if (onCancel) onCancel();
      };
    } else { // 'alert' type
      cancelBtn.style.display = 'none';
      confirmBtn.innerText = 'OK';
      confirmBtn.onclick = () => {
        overlay.classList.remove('show');
        if (onConfirm) onConfirm();
      };
    }
    overlay.classList.add('show');
  };

  // --- User Selection Modal Functions ---
  const userSelectionModalOverlay = document.getElementById('user-selection-modal-overlay');
  const userSelectionList = document.getElementById('user-selection-list');
  const selectUsersConfirmBtn = document.getElementById('select-users-confirm');
  const selectUsersCancelBtn = document.getElementById('select-users-cancel');

  const showUserSelectionModal = (users) => {
    userSelectionList.innerHTML = ''; // Clear previous list
    users.forEach(user => {
      const label = document.createElement('label');
      label.innerHTML = `<input type="checkbox" value="${user.sid}" data-name="${user.name}"> ${user.name}`;
      userSelectionList.appendChild(label);
    });
    userSelectionModalOverlay.classList.add('show');
  };

  const hideUserSelectionModal = () => {
    userSelectionModalOverlay.classList.remove('show');
  };

  selectUsersConfirmBtn.onclick = () => {
    const selectedSids = Array.from(userSelectionList.querySelectorAll('input[type="checkbox"]:checked'))
                               .map(checkbox => checkbox.value);

    if (selectedSids.length === 0) {
      showMessageBox("Please select at least one person to call.", 'alert');
      return;
    }

    if (selectedSids.length > 1) {
        showMessageBox("For now, you can only select one person for a video call. Please choose one.", 'alert');
        return;
    }

    hideUserSelectionModal();
    // For simplicity, we'll only initiate a call with the first selected user
    // True multi-party calls require a more complex WebRTC architecture (SFU/MCU)
    initiateCallWithSelectedUser(selectedSids[0]);
  };

  selectUsersCancelBtn.onclick = () => {
    hideUserSelectionModal();
    videoCallBtn.innerText = "📞 Start Video Call"; // Reset button text
    videoCallBtn.classList.remove("hangup");
    videoCallBtn.disabled = false; // Re-enable button
  };

  // Function to create and append message elements with dynamic colors
  const createMessage = (name, msg, color) => {
    const content = document.createElement("div");
    content.classList.add("text");
    content.style.backgroundColor = color; // Apply the background color
    content.style.color = "black"; // Ensure text is black for readability

    content.innerHTML = `
      <span><strong>${name}</strong>: ${msg}</span>
    `;
    messages.appendChild(content);
    messages.scrollTop = messages.scrollHeight; // Auto-scroll to bottom

    // Auto-delete oldest messages if in privacy mode and limit exceeded
    if (mode === "privacy" && messages.children.length > 5) {
      messages.removeChild(messages.firstChild);
    }
  };

  // Socket.IO event listeners
  socketio.on("message", data => {
    createMessage(data.name, data.message, data.color);
  });

  socketio.on("user_count", count => {
    document.getElementById("user-count").innerText = count;
    const xoxGameBtn = document.getElementById('xox-game-btn');
    if (count >= 2) {
        xoxGameBtn.disabled = false;
    } else {
        xoxGameBtn.disabled = true;
        if (!gameActive) {
            xoxGameContainer.classList.remove('active');
            isXOXVisible = false;
            document.getElementById('xox-game-btn').innerText = 'Play XOX';
        }
    }
  });

  socketio.on("typing", data => {
    typingIndicator.innerText = `${data.name} is typing...`;
    clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => typingIndicator.innerText = "", 1500);
  });

  // NEW: Socket.IO event to receive list of online users
  socketio.on("room_users_list", (users) => {
    onlineUsers = users; // Store the list of users
    if (users.length > 0) {
      showUserSelectionModal(users);
    } else {
      showMessageBox("No other users available to call in this room.", 'alert');
      videoCallBtn.innerText = "📞 Start Video Call";
      videoCallBtn.classList.remove("hangup");
      videoCallBtn.disabled = false;
    }
  });

  // NEW: Socket.IO event to update online users (e.g., when someone joins/leaves)
  socketio.on("online_users_update", (users) => {
      onlineUsers = users;
      // If the modal is currently open, update its list
      if (userSelectionModalOverlay.classList.contains('show')) {
          showUserSelectionModal(onlineUsers);
      }
  });


  // --- WebRTC Signaling Events ---
  socketio.on("call_request", (data) => {
    if (isCalling) {
      console.log("Already in a call, rejecting incoming call.");
      socketio.emit("call_response", { action: "reject", requester_sid: data.requester_sid });
      return;
    }
    remoteRequesterSid = data.requester_sid;

    showMessageBox(`${data.from} is calling you. Do you want to accept?`, 'confirm',
      async () => {
        isInitiator = false;
        isCalling = true;
        videoCallBtn.innerText = "Hang Up";
        videoCallBtn.classList.add("hangup");
        videoCallBtn.disabled = true;

        const setupSuccess = await startVideoCallInternal();
        if (setupSuccess) {
          socketio.emit("call_response", { action: "accept", requester_sid: remoteRequesterSid });
          await createAnswer();
          createMessage("System", `You accepted a call from ${data.from}.`);
          videoCallBtn.disabled = false;
        } else {
          socketio.emit("call_response", { action: "reject", requester_sid: remoteRequesterSid });
          createMessage("System", "Could not start video call. Check permissions/devices.");
          endVideoCall();
        }
      },
      () => {
        socketio.emit("call_response", { action: "reject", requester_sid: remoteRequesterSid });
        createMessage("System", `You rejected a call from ${data.from}.`);
        remoteRequesterSid = null;
      }
    );
  });

  socketio.on("call_accepted", async (data) => {
      isCalling = true;
      videoCallBtn.innerText = "Hang Up";
      videoCallBtn.classList.add("hangup");
      videoCallBtn.disabled = false;
      createMessage("System", `${data.from} accepted your call.`);
      await createOffer();
  });

  socketio.on("call_rejected", (data) => {
    showMessageBox(`${data.from} ${data.reason}`, 'alert');
    endVideoCall();
  });

  socketio.on("call_status", (data) => {
      createMessage("System", data.message);
  });

  socketio.on("offer", async (data) => {
    if (!peerConnection) {
        const setupSuccess = await startVideoCallInternal();
        if (!setupSuccess) {
            console.error("Failed to setup peer connection on offer receive.");
            return;
        }
    }
    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
    if (!isInitiator) {
      await createAnswer();
    }
  });

  socketio.on("answer", async (data) => {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
  });

  socketio.on("ice_candidate", async (data) => {
    try {
      if (peerConnection && data.candidate) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    } catch (e) {
      console.error("Error adding received ICE candidate:", e);
    }
  });

  socketio.on("call_end", (data) => {
    endVideoCall();
    createMessage("System", `${data.name} has ended the video call.`);
  });

  // --- WebRTC Functions ---
  const startVideoCallInternal = async (deviceId = null) => {
    try {
      if (localStream) { // Stop existing stream if switching camera
          localStream.getTracks().forEach(track => track.stop());
      }
      const constraints = {
          video: deviceId ? { deviceId: { exact: deviceId } } : true,
          audio: true
      };
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      localVideo.srcObject = localStream;
      localVideoWrapper.classList.add('active');

      // Store the current camera device ID
      const videoTrack = localStream.getVideoTracks()[0];
      if (videoTrack) {
          currentCameraDeviceId = videoTrack.getSettings().deviceId;
      }

      // If peerConnection already exists, replace tracks
      if (peerConnection) {
          const senders = peerConnection.getSenders();
          senders.forEach(sender => {
              if (sender.track && sender.track.kind === 'video') {
                  sender.replaceTrack(videoTrack);
              } else if (sender.track && sender.track.kind === 'audio') {
                  sender.replaceTrack(localStream.getAudioTracks()[0]);
              }
          });
      } else {
          // Create PeerConnection if it doesn't exist
          peerConnection = new RTCPeerConnection(iceServers);

          localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
          });

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              socketio.emit("ice_candidate", { candidate: event.candidate });
            }
          };

          peerConnection.ontrack = (event) => {
            if (remoteVideo.srcObject !== event.streams[0]) {
              remoteVideo.srcObject = event.streams[0];
              remoteVideoWrapper.classList.add('active');
            }
          };

          peerConnection.onconnectionstatechange = (event) => {
            console.log('PeerConnection state change:', peerConnection.connectionState);
            if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
              if (isCalling) {
                if (videoCallBtn.innerText !== "📞 Start Video Call") {
                    endVideoCall();
                    createMessage("System", "Video call disconnected due to network issues or peer leaving.");
                }
              }
            } else if (peerConnection.connectionState === 'connected') {
              createMessage("System", "Video call connected!");
            }
          };

          peerConnection.oniceconnectionstatechange = (event) => {
            console.log('ICE connection state change:', peerConnection.iceConnectionState);
          };
      }

      // Show video controls
      document.querySelector('.video-controls-overlay').style.display = 'flex';

      return true;
    } catch (error) {
      console.error("Error accessing media devices or setting up WebRTC:", error);
      endVideoCall();

      let errorMessage = "Could not start video call. ";
      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
        errorMessage += "Please grant camera and microphone permissions in your browser settings.";
      } else if (error.name === 'NotFoundError') {
        errorMessage += "No camera or microphone found. Please ensure devices are connected.";
      } else {
        errorMessage += `An unexpected error occurred: ${error.name} - ${error.message}`;
      }
      showMessageBox(errorMessage, 'alert');
      videoCallBtn.disabled = true;
      videoCallBtn.innerText = "Error!";
      return false;
    }
  };

  const createOffer = async () => {
    try {
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socketio.emit("offer", { offer: peerConnection.localDescription });
    } catch (error) {
      console.error("Error creating offer:", error);
    }
  };

  const createAnswer = async () => {
    try {
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      socketio.emit("answer", { answer: peerConnection.localDescription });
    } catch (error) {
      console.error("Error creating answer:", error);
    }
  };

  const endVideoCall = () => {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    localVideo.srcObject = null;
    remoteVideo.srcObject = null;
    localVideoWrapper.classList.remove('active');
    remoteVideoWrapper.classList.remove('active');
    isCalling = false;
    isInitiator = false;
    remoteRequesterSid = null;
    videoCallBtn.innerText = "📞 Start Video Call";
    videoCallBtn.classList.remove("hangup");
    videoCallBtn.disabled = false;
    document.querySelector('.video-controls-overlay').style.display = 'none'; // Hide video controls
    if (document.fullscreenElement) { // Exit fullscreen if active
        document.exitFullscreen();
    }
  };

  // --- User Interaction Functions ---
  const sendMessage = () => {
    const msg = messageInput.value.trim();
    if (msg === "") return;
    socketio.emit("message", { data: msg });
    messageInput.value = "";
  };

  const handleKeyPress = event => {
    if (event.key === "Enter") sendMessage();
  };

  const notifyTyping = () => {
    socketio.emit("typing");
  };

  const initiateCallWithSelectedUser = async (targetSid) => {
    isInitiator = true;
    videoCallBtn.innerText = "Calling...";
    videoCallBtn.classList.add("hangup");
    videoCallBtn.disabled = true;

    const setupSuccess = await startVideoCallInternal();
    if (!setupSuccess) {
      isCalling = false;
      isInitiator = false;
      videoCallBtn.innerText = "📞 Start Video Call";
      videoCallBtn.classList.remove("hangup");
      return;
    }

    isCalling = true;
    socketio.emit("call_request", { target_sid: targetSid });

    setTimeout(() => {
      if (isCalling && isInitiator && peerConnection && !peerConnection.remoteDescription) {
        showMessageBox("No one answered your call.", 'alert');
        socketio.emit("call_end");
        endVideoCall();
      }
    }, 30000);
  };

  const toggleVideoCall = async () => {
    if (videoCallBtn.disabled && videoCallBtn.innerText !== "Calling...") {
      showMessageBox("Video call is unavailable. Please check camera/microphone permissions or device connection.", 'alert');
      return;
    }

    if (!isCalling) {
      const userCount = parseInt(document.getElementById("user-count").innerText);
      if (userCount < 2) {
        showMessageBox("Need at least 2 users in the room for a video call.", 'alert');
        return;
      } else if (userCount > 2) {
        // If more than 2 users, prompt for selection
        socketio.emit("get_room_users"); // Request list of online users
        videoCallBtn.innerText = "Calling..."; // Indicate a process is starting
        videoCallBtn.classList.add("hangup");
        videoCallBtn.disabled = true;
      } else {
        // Exactly 2 users, proceed with direct 1:1 call
        initiateCallWithSelectedUser(null); // Pass null to let server find the other peer
      }
    } else {
      socketio.emit("call_end");
      endVideoCall();
    }
  };

  const toggleDarkMode = () => {
    const body = document.body;
    const isDark = body.style.getPropertyValue("--bg-color") === "black";

    body.style.setProperty("--bg-color", isDark ? "#ece6fa" : "black");
    body.style.setProperty("--text-color", isDark ? "black" : "white");

    const chatBgLight = "linear-gradient(135deg, #ece6fa, #ece6fa)";
    const chatBgDark = "linear-gradient(135deg, #222, #333)";

    document.querySelector('.chat-container').style.background = isDark ? chatBgLight : chatBgDark;
    document.querySelector('.inputs-container').style.background = isDark ? chatBgLight : chatBgDark;

    messageInput.style.color = isDark ? 'black' : 'white';
  };

  const leaveRoom = () => {
    if (isCalling) {
      socketio.emit("call_end");
    }
    window.location.href = "/logout"; // Redirect to logout page to clear session
  };

  // --- Video Call Controls ---
  function toggleMute() {
      if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
              audioTrack.enabled = !audioTrack.enabled;
              muteToggleButton.innerText = audioTrack.enabled ? '🔇' : '🎤';
              muteToggleButton.classList.toggle('active', !audioTrack.enabled);
          }
      }
  }

  async function switchCamera() {
      if (!localStream) {
          showMessageBox("No active video stream to switch camera.", 'alert');
          return;
      }

      const videoTrack = localStream.getVideoTracks()[0];
      if (!videoTrack) {
          showMessageBox("No video track found.", 'alert');
          return;
      }

      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(device => device.kind === 'videoinput');

      if (videoDevices.length <= 1) {
          showMessageBox("Only one camera found or no other cameras available.", 'alert');
          return;
      }

      const currentDeviceId = videoTrack.getSettings().deviceId;
      const nextDevice = videoDevices.find(device => device.deviceId !== currentDeviceId);

      if (nextDevice) {
          // Stop current track
          videoTrack.stop();
          // Restart stream with new device
          await startVideoCallInternal(nextDevice.deviceId);
      } else {
          // This case should ideally not be hit if videoDevices.length > 1
          showMessageBox("Could not find another camera to switch to.", 'alert');
      }
  }

  function toggleFullscreen() {
      if (!document.fullscreenElement) {
          if (videoContainer.requestFullscreen) {
              videoContainer.requestFullscreen();
          } else if (videoContainer.webkitRequestFullscreen) { /* Safari */
              videoContainer.webkitRequestFullscreen();
          } else if (videoContainer.msRequestFullscreen) { /* IE11 */
              videoContainer.msRequestFullscreen();
          }
          fullscreenToggleButton.innerText = 'fullscreen_exit';
      } else {
          if (document.exitFullscreen) {
              document.exitFullscreen();
          } else if (document.webkitExitFullscreen) { /* Safari */
              document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) { /* IE11 */
              document.msExitFullscreen();
          }
          fullscreenToggleButton.innerText = 'expand_content';
      }
      videoContainer.classList.toggle('fullscreen', !document.fullscreenElement);
      adjustLayoutForKeyboard(); // Re-adjust layout after fullscreen toggle
  }

  // Listen for fullscreen change events
  document.addEventListener('fullscreenchange', () => {
      videoContainer.classList.toggle('fullscreen', document.fullscreenElement !== null);
      fullscreenToggleButton.innerText = document.fullscreenElement ? 'fullscreen_exit' : 'expand_content';
      adjustLayoutForKeyboard();
  });
  document.addEventListener('webkitfullscreenchange', () => {
      videoContainer.classList.toggle('fullscreen', document.webkitFullscreenElement !== null);
      fullscreenToggleButton.innerText = document.webkitFullscreenElement ? 'fullscreen_exit' : 'expand_content';
      adjustLayoutForKeyboard();
  });
  document.addEventListener('msfullscreenchange', () => {
      videoContainer.classList.toggle('fullscreen', document.msFullscreenElement !== null);
      fullscreenToggleButton.innerText = document.msFullscreenElement ? 'fullscreen_exit' : 'expand_content';
      adjustLayoutForKeyboard();
  });


  // --- XOX Game Variables and Functions ---
  const xoxGameContainer = document.getElementById('xox-game-container');
  const xoxBoard = document.getElementById('xox-board');
  const xoxCells = document.querySelectorAll('.xox-cell');
  const xoxStatus = document.getElementById('xox-status');
  const xoxStartBtn = document.getElementById('xox-start-btn');
  const xoxResetBtn = document.getElementById('xox-reset-btn');

  let board = ['', '', '', '', '', '', '', '', ''];
  let currentPlayer = 'X';
  let gameActive = false;
  let yourSymbol = null;
  let isYourTurn = false;
  let playerXName = '';
  let playerOName = '';
  let isXOXVisible = false;

  const winningConditions = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8],
      [0, 3, 6], [1, 4, 7], [2, 5, 8],
      [0, 4, 8], [2, 4, 6]
  ];

  const toggleXOXVisibility = () => {
      isXOXVisible = !isXOXVisible;
      if (isXOXVisible) {
          xoxGameContainer.classList.add('active');
          document.getElementById('xox-game-btn').innerText = 'Hide XOX';
          updateGameStatus();
          adjustLayoutForKeyboard();
      } else {
          xoxGameContainer.classList.remove('active');
          document.getElementById('xox-game-btn').innerText = 'Play XOX';
          adjustLayoutForKeyboard();
      }
  };

  const initializeBoard = () => {
      board = ['', '', '', '', '', '', '', '', ''];
      xoxCells.forEach(cell => {
          cell.innerText = '';
          cell.classList.remove('x', 'o', 'winning-cell');
          cell.style.pointerEvents = 'none';
          cell.removeEventListener('click', handleCellClick);
          cell.addEventListener('click', handleCellClick);
      });
      gameActive = false;
      yourSymbol = null;
      isYourTurn = false;
      playerXName = '';
      playerOName = '';
      xoxStatus.innerText = 'Need 2 players to start XOX.';
      xoxStartBtn.style.display = 'block';
      xoxResetBtn.style.display = 'none';
      currentPlayer = 'X';
      xoxStartBtn.disabled = true;
  };

  const checkWinner = () => {
      let roundWon = false;
      let winningCells = [];
      for (let i = 0; i < winningConditions.length; i++) {
          const winCondition = winningConditions[i];
          let a = board[winCondition[0]];
          let b = board[winCondition[1]];
          let c = board[winCondition[2]];

          if (a === '' || b === '' || c === '') {
              continue;
          }
          if (a === b && b === c) {
              roundWon = true;
              winningCells = winCondition;
              break;
          }
      }

      if (roundWon) {
          gameActive = false;
          highlightWinningCells(winningCells);
          const winnerDisplay = board[winningCells[0]] === 'X' ? playerXName : playerOName;
          const winnerSymbol = board[winningCells[0]];
          xoxStatus.innerText = `${winnerDisplay} (${winnerSymbol}) has won!`;
          socketio.emit("game_over", { winner: winnerSymbol, draw: false, message: `${winnerDisplay} won the XOX game!` });
          xoxStartBtn.style.display = 'none';
          xoxResetBtn.style.display = 'block';
          return true;
      }

      if (!board.includes('')) {
          gameActive = false;
          xoxStatus.innerText = 'Game Draw!';
          socketio.emit("game_over", { winner: null, draw: true, message: "XOX game ended in a draw!" });
          xoxStartBtn.style.display = 'none';
          xoxResetBtn.style.display = 'block';
          return true;
      }
      return false;
  };

  const highlightWinningCells = (cells) => {
      cells.forEach(index => {
          xoxCells[index].classList.add('winning-cell');
      });
  };

  const handleCellClick = (event) => {
      const clickedCell = event.target;
      const clickedCellIndex = parseInt(clickedCell.dataset.index);

      if (!gameActive || board[clickedCellIndex] !== '' || !isYourTurn) {
          return;
      }

      board[clickedCellIndex] = yourSymbol;
      clickedCell.innerText = yourSymbol;
      clickedCell.classList.add(yourSymbol.toLowerCase());
      clickedCell.style.pointerEvents = 'none';

      const nextPlayerSymbol = yourSymbol === 'X' ? 'O' : 'X';

      socketio.emit("game_move", {
          index: clickedCellIndex,
          symbol: yourSymbol,
          next_turn_symbol: nextPlayerSymbol,
          board_state: board
      });

      isYourTurn = false;
      updateGameStatus();
  };

  // --- Socket.IO Game Event Handlers ---

  socketio.on("enable_game_start", () => {
      const userCount = parseInt(document.getElementById("user-count").innerText);
      if (userCount >= 2 && !gameActive) {
          xoxStartBtn.disabled = false;
          xoxStatus.innerText = 'Two players are in the room. Click "Start New XOX Game"!';
      }
  });

  socketio.on("disable_game_start", () => {
      xoxStartBtn.disabled = true;
      if (!gameActive) {
          xoxStatus.innerText = 'Need 2 players to start XOX.';
      }
  });

  socketio.on("game_status", (data) => {
      createMessage("System", `XOX: ${data.message}`);
      if (!gameActive) {
        xoxStatus.innerText = data.message;
      }
  });

  socketio.on("game_start", (data) => {
      initializeBoard();
      gameActive = true;
      yourSymbol = data.your_symbol;
      isYourTurn = data.is_your_turn;
      playerXName = data.player_x_name;
      playerOName = data.player_o_name;

      xoxStartBtn.style.display = 'none';
      xoxResetBtn.style.display = 'none';

      createMessage("System", `XOX game started! ${playerXName} is X, ${playerOName} is O. You are **${yourSymbol}**.`);
      updateGameStatus();
  });

  socketio.on("game_update", (data) => {
      if (!gameActive || board[data.index] !== '') {
          console.warn("Received invalid game update or game not active.");
          return;
      }

      board[data.index] = data.symbol;
      const cell = xoxCells[data.index];
      cell.innerText = data.symbol;
      cell.classList.add(data.symbol.toLowerCase());
      cell.style.pointerEvents = 'none';

      isYourTurn = (data.current_turn_sid === socketio.id);

      updateGameStatus();
      checkWinner();
  });

  socketio.on("game_result", (data) => {
      gameActive = false;
      isYourTurn = false;
      xoxStartBtn.style.display = 'none';
      xoxResetBtn.style.display = 'block';
      createMessage("System", `XOX Game Over: ${data.message}`);
      if (data.draw) {
          xoxStatus.innerText = 'Game Draw!';
      } else if (data.winner) {
          const winnerDisplayName = data.winner === 'X' ? playerXName : playerOName;
          xoxStatus.innerText = `${winnerDisplayName} (${data.winner}) has won!`;
      }
      xoxCells.forEach(cell => cell.style.pointerEvents = 'none');
      xoxStartBtn.disabled = false;
  });

  socketio.on("game_reset", (data) => {
      initializeBoard();
      createMessage("System", `XOX Game Reset: ${data.reason}`);
      const userCount = parseInt(document.getElementById("user-count").innerText);
      if (userCount >= 2) {
          xoxStartBtn.disabled = false;
          xoxStatus.innerText = 'Two players are in the room. Click "Start New XOX Game"!';
      } else {
          xoxStatus.innerText = 'Need 2 players to start XOX.';
      }
  });


  const startGame = () => {
      if (parseInt(document.getElementById("user-count").innerText) < 2) {
          showMessageBox("You need 2 players in the room to start an XOX game.", 'alert');
          return;
      }
      xoxStartBtn.disabled = true;
      socketio.emit("game_start_request");
  };

  const resetGame = () => {
      xoxResetBtn.disabled = true;
      socketio.emit("game_reset_request");
  };

  const updateGameStatus = () => {
    if (!gameActive) {
        if (!xoxStatus.innerText.includes("won") && !xoxStatus.innerText.includes("Draw") && yourSymbol === null) {
            const userCount = parseInt(document.getElementById("user-count").innerText);
            xoxStatus.innerText = userCount < 2 ? 'Need 2 players to start XOX.' : 'Waiting for a new game to start.';
        }
    } else {
        const currentPlayerName = currentPlayer === 'X' ? playerXName : playerOName;
        const yourTurnText = isYourTurn ? 'Your turn!' : '';
        xoxStatus.innerText = `${currentPlayerName}'s turn (${currentPlayer}). ${yourTurnText}`;
    }
    xoxCells.forEach(cell => {
        if (gameActive && isYourTurn && board[parseInt(cell.dataset.index)] === '') {
            cell.style.pointerEvents = 'auto';
        } else {
            cell.style.pointerEvents = 'none';
        }
    });
  };

  initializeBoard();

  // --- Mobile Keyboard Alignment Logic ---
  const adjustLayoutForKeyboard = () => {
    const viewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;

    const controlsHeight = controls.offsetHeight;
    const inputsHeight = inputsContainer.offsetHeight;
    const typingIndicatorHeight = typingIndicator.innerText ? typingIndicator.offsetHeight : 0;
    const videoContainerHeight = document.getElementById('video-container').offsetHeight;
    const xoxContainerHeight = isXOXVisible ? xoxGameContainer.offsetHeight : 0;

    const chatContainerPaddingTop = parseFloat(getComputedStyle(chatContainer).paddingTop);
    const chatContainerPaddingBottom = parseFloat(getComputedStyle(chatContainer).paddingBottom);
    const totalContainerPadding = chatContainerPaddingTop + chatContainerPaddingBottom;

    const messagesAvailableHeight = viewportHeight - controlsHeight - inputsHeight - typingIndicatorHeight - videoContainerHeight - xoxContainerHeight - totalContainerPadding;

    messages.style.maxHeight = `${messagesAvailableHeight}px`;

    messages.scrollTop = messages.scrollHeight;
  };

  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', adjustLayoutForKeyboard);
  } else {
    window.addEventListener('resize', adjustLayoutForKeyboard);
  }

  window.addEventListener('load', () => {
    adjustLayoutForKeyboard();
    const userCount = parseInt(document.getElementById("user-count").innerText);
    if (userCount >= 2 && !gameActive) {
        document.getElementById('xox-game-btn').disabled = false;
        xoxStartBtn.disabled = false;
        xoxStatus.innerText = 'Two players are in the room. Click "Start New XOX Game"!';
    } else {
        document.getElementById('xox-game-btn').disabled = true;
        xoxStartBtn.disabled = true;
    }
  });
  messageInput.addEventListener('focus', adjustLayoutForKeyboard);
  messageInput.addEventListener('blur', adjustLayoutForKeyboard);

</script>

{% for msg in messages %}
<script type="text/javascript">
  createMessage("{{ msg.name }}", "{{ msg.message }}", "{{ msg.color }}");
</script>
{% endfor %}
{% endblock %}